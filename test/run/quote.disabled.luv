// - quote QuotedList makes a global available to macros
// - a macro can QuotedList.unquote({expansions}) which just
//   substitutes Idents in for TIdents
// - the macro helpers can append/insert/return as necessary
//
// for list in particular, the compiler can assume that there's various things
// in the prelude and just do the same macro expansion (slightly handwavy)
//
// Various patterns for instantiating seem fine, but maybe eventually can have a
// magical syntax that allows the automatic instantiation based on declaring a
// type with the type parameters instantiated.
// - Would need some logic similar to macro to build the Idents and other
// derived types, so maybe it's just a matter of some symbol manipulation in
// that macro (i.e. to build the other idents based on args[0]).
// ... so maybe the magic syntax is just calling the macro?

// Messy stuff:
// - quote lives in luv, but macro in py (ok for prelude, gross for user code)
//   ... but mostly goes away once parser allows a suite of python code inline


//def List(macro):
//  list.unquote({
//    '`C': last.Ident("List$i32"),
//    '`T': last.Ident("i32"),
//    '`I': last.Ident("ListIter$i32"),
//  })
//
//def List(macro):
//  // TODO: t.name isn't right because of base type vs struct
//  t = macro.args[0]
//  c = last.Ident("List$" + t.name)
//  i = last.Ident("ListIter$" + t.name)
//  if not macro.have_global(c):
//    macro.insert_global(QuotedList.unquote({...}))
//  return macro.parse_expr(c)
//

// `C for container
// `T for contained type
// `I for iterator

import_macros "quote.mac.py"

quote QuotedList:
  struct `C:
    *`T ptr
    int len
    int cap

  struct `I:
    *`C seq
    int cur

  on `C def __getitem__(self, int at):
    assert at >= 0 and at < self.len
    return self.ptr[at]

  on `C def __iter__(self):
    return `I(self, 0)

  on `C def __del__(self):
    C.free(self.ptr)
    self.ptr = null
    self.len = 0
    self.cap = 0

  on `C def reserve(self, int cap):
    if self.cap < cap:
      newcap = cap
      if newcap < 16: newcap = 16
      while newcap < cap:
        newcap *= 2
      *int newp = C.malloc(sizeof(`T) * newcap)
      C.memcpy(newp, self.ptr, sizeof(`T) * self.len)
      C.free(self.ptr)
      self.ptr = newp
      self.cap = newcap

  on `C def append(self, int value):
    self.reserve(self.len + 1)
    self.ptr[self.len] = value
    self.len += 1


  on `I def __next__(self):
    if self.cur >= self.seq.len:
      return false, 0
    ret = self.seq.ptr[self.cur]
    self.cur += 1
    return true, ret

